---
title: "FDZ_Data_Cleaning"
author: "Annegret Rucker"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FDZ_Data_Cleaning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In the following, the FDZ data preparation is documented.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
library(eatGADS)
sav_path <- system.file("extdata", "example_data.sav", package = "eatFDZ")
dat <- import_spss(sav_path)

#### Basisinformationen festlegen ####
studyname <- "data_prep" # hier Akronym eintragen, wie es im Ordnernamen steht
# (ggf. auch "Zwischenordner" eintragen, z.B. "StEG/StEG_Tandem")

# Pfade aller Datensaetze zusammenfuegen + suchen
#   (ggf. sollten Pfade ueberprueft und angepasst werden, falls bspw.
#     einige Dateien anders abgelegt sind)
sav_path_base <- file.path("Q:/FDZ/Alle/01_Studien",
                           studyname,
                           "1a_Daten/2_Arbeitskopie")
sav_list <- list.files(sav_path_base, recursive = TRUE,
                       pattern = ".sav", full.names = TRUE)

out_path_base <- file.path("Q:/FDZ/Alle/01_Studien",
                           studyname,
                           "1a_Daten/3_IZA/v1")

#------------------------------------------------------------------------------
#### Schuelerdatensatz #####

# einzelnen Datensatz laden (richtigen auswaehlen!)
dat <- import_spss(sav_list[1])
```

# -----------------------------------------------------------------------------
## Recode missings semi-automatically
At this place the missings are recoded semi-automatically. With `checkMissings()` it is tested where the above specified missings labels occur in the data and corresponding items are tagged as missing.
```{r checkMissings}
missinglabels <- paste("missing", "unknown",
                       "omitted", "unclear answer",
                       sep = "|")
dat1 <- checkMissings(dat, missingLabel = missinglabels)
```
Similar principle here, only that here a certain range of values is tagged as missing.
```{r checkMissingsByValues}
dat1 <- checkMissingsByValues(dat1, missingValues = -50:-99)
```


# -----------------------------------------------------------------------------
## Recode IDs
The first step is to create the path for the template.
```{r IDrecode}
ID_recode_template <- file.path("Q:/FDZ/Alle/01_Studien",
                                studyname,
                                "4_Aufbereitung",
                                "xxx_Rekodierung_template.csv") ## Adapt file name if necessary
```
Then, you have two options: Create a new template (option 1) or apply an existing template (option 2).

### Option 1: Recode IDs with creation of a template as .csv
A recoding template is created here.
```{r autoRecode}
dat2 <- autoRecode(dat1, var = "ID", var_suffix = "_FDZ", csv_path = ID_recode_template, label_suffix = " (rekodiert FDZ)")
```
### Option 2: Recode IDs with application of a template (e.g. created by a previously prepared, different data set).
Here an already existing template was applied.
```{r autoRecode2, eval = FALSE}
template <- read.csv(ID_recode_template)
dat2 <- autoRecode(dat1, var = "ID", suffix = "_FDZ", csv_path = ID_recode_template, template = template,
                   label_suffix = "(rekodiert FDZ)") ## Apply template and overwrite
```

Delete old ID variables if necessary.
```{r removeVars}
dat3 <- removeVars(dat2, vars = c("ID"))
```

# -----------------------------------------------------------------------------
## Convert string variables to numeric variables
String variables cause problems in some statistical programs. In addition, it is more difficult to select the answers in the evaluations with string variables than with numerical codes. Therefore, we convert string variables into numeric variables.
To do so, all string variables are identified first.
```{r docall}
all_types <- do.call(rbind, lapply(namesGADS(dat3), function(nam) data.frame(varName = nam, type = class(dat3$dat[[nam]]))))
all_types[all_types$type == "character", ]
```
In this case the variables "ID_name", "info", "subjfav" and "birth" were recognized as string variables. In the next step they can be converted.

### Option 1: convert all string variables automatically (overwrite variables)
```{r allTypes}
charNames <- all_types[all_types$type == "character", "varName"]
for(charName in charNames) {
  dat4 <- multiChar2fac(dat3, vars = charName, var_suffix = "", label_suffix = "")
}
```
### Option 2: Convert string variable individually
Convert to a new variable:
```{r multiChar2fac, eval=FALSE}
dat4 <- multiChar2fac(dat3, vars = c("ID_name", "info", "subjfav", "birth"), var_suffix = "_FDZ", label_suffix = "")
```
Overwrite variable:
```{r multiChar2fac2, eval=FALSE}
dat4 <- multiChar2fac(dat3, vars = c("ID_name", "info", "subjfav", "birth"), var_suffix = "", label_suffix = "")
```

# -----------------------------------------------------------------------------
## Empty variables already in IZA (with loop)
If variables are of strong data protection concern, they are already emptied directly in the IZA. This is achieved with the `emptyTheseVariables()` function.
```{r emptyTheseVariables}
dat3_empty <- c("info",
                "ID_name")
dat3 <- emptyTheseVariables(dat3,
                            vars = dat3_empty,
                            label_suffix = " (Zur Anonymisierung geleert (FDZ))")
```
`dat3` corresponds to the dataset here, `vars` describes the variables to be emptied and `label_suffix` automatically adds the declaration to the variable label that the data has been emptied for anonymization.

# -----------------------------------------------------------------------------
## Anonymization: Form grouping variable
For anonymization reasons, we partially form grouping variables for items with a case number <6. To do this, we create a new _FDZ variable by "cloning" the variable we want to group with `cloneVariable()`. For `varName` we enter the original variable name, for `new_varName` we enter the variable name including the appendix "_FDZ". The variable label is automatically adjusted with the option `label_suffix`.
With `recodeGADS()` the old values (`oldValues`) are replaced by new ones (`newValues`). With the help of `changeValLabels()` the value labels of the new groupings are changed.
```{r recodeGADS}
dat5 <- cloneVariable(dat4, varName = "age", new_varName = "age_FDZ", label_suffix = " (Zur Anonymisierung aggregiert (FDZ))")

dat5 <- recodeGADS(dat5, varName = "age_FDZ", oldValues = c(13, 14, 15, 17),
                  newValues = c(13, 13, 15, 15))
dat5 <- changeValLabels(dat5, varName = "age_FDZ", value = c(13, 15), valLabel = c("13-14", "15-17"))
```

## Change variable and value labels
To change variable or value labels, the functions `ChangeVarLabels()` and `ChangeValLabels()` are helpful. In `ChangeVarLabels()` the variable to be changed is selected under `varName` and with `varLabel` the corresponding label is assigned. `ChangeValLabels()` works the same way, except that the corresponding value is selected, too.
```{r changeVarLabels}
dat6 <- changeVarLabels(dat5, varName = "ID_name", varLabel = "Vorname")
dat6 <- changeValLabels(dat6, varName = "books", value = 5, valLabel = "201-500 books")
```

## Define missing values
Using `changeMissings()`, missing values can be tagged as missings by specifying them under `value` and marking them as `miss` under `missings.`
```{r changeMissings}
dat7 <- changeMissings(dat6, varName = "school", value = c(-97, -98, -99), missings = c("miss", "miss", "miss"))
```

# -----------------------------------------------------------------------------
## Creating the version variable
To indicate the state of the dataset, each dataset is provided with a version variable. This is created using `createVariable()` and placed at the beginning of the record by `relovateVariable()` so that it has a consistent, visible place.
```{r VersionsVar}
version_name <- "Version_v1_2023_07"
dat8 <- createVariable(dat7, varName = version_name)
dat8 <- relocateVariable(dat8, var = version_name, after = NULL)
```

# -----------------------------------------------------------------------------
## Change variable order
To rearrange the variables of a data set, the function `orderLike()` helps, in which the variables are listed in their new order.
```{r orderLike}
dat9 <- orderLike(dat8, newOrder = c("Version_v1_2023_07", "ID_FDZ", "ID_name", "info", "home", "birth", "age", "age_FDZ", "sex", "siblings", "books", "school", "subjfav"))
```
To sort in individual variables, such as newly created grouping variables behind their emptied original variable, `relocateVariable()` can be used.
```{r relocateVariable}
dat9 <- relocateVariable(dat9, var = "age_FDZ", after = "age")
```
