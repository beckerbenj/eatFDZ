---
title: "FDZ_Data_Cleaning"
author: "Annegret Rucker"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FDZ_Data_Cleaning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette is about preparing SPSS data. The goal is to end up with a high-quality, traceable, comprehensible, anonymized data set with meaningful metadata. To do this, we will go over functions such as ID recoding, emptying variables, changing labels, creating grouping variables, and many more. 

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
```
We start with a little setup.
``` {r path}
library(eatGADS)
sav_path <- system.file("extdata", "example_data.sav", package = "eatFDZ")
dat <- import_spss(sav_path)
```
We use an artificial example data set with the subject of secondary school students in Berlin. The data set is intentionally flawed and messy and will be prepared using the following steps.

# -----------------------------------------------------------------------------
Loading a single data set (be careful to select the right one)
```{r load}
dat <- import_spss(sav_path)
str(dat$dat) # for a small overview in the variables of the data set
```

# -----------------------------------------------------------------------------
## Recode missings semi-automatically
Sometimes not all missing values are really defined as missing. At this place the missings are recoded semi-automatically. With `checkMissings()` it is tested where the above specified missings labels occur in the data and corresponding items are tagged as missing.
```{r checkMissings}
missinglabels <- paste("missing", "unknown",
                       "omitted", "unclear answer",
                       sep = "|")
dat1 <- checkMissings(dat, missingLabel = missinglabels)
```
Similar principle here, only that here a certain range of values is tagged as missing.
```{r checkMissingsByValues}
dat2 <- checkMissingsByValues(dat1, missingValues = -50:-99)
```

# -----------------------------------------------------------------------------
## Recode IDs
To ensure that the IDs remain the same across multiple subsets and describe the same person, we recode them using a template. The first step is to create the path for the template.
```{r IDrecode, eval = FALSE}
f <- tempfile()
ID_recode_template <- file.path("f") ## use your own file path instead of the tempfile
```
Then, you have two options: Create a new template (option 1 - for the first subset) or apply an existing template (option 2 - for the following subsets).

### Option 1: Recode IDs with creation of a template as .csv
A recoding template is created here.
```{r autoRecode, eval = FALSE}
dat2 <- autoRecode(dat2, var = "ID", var_suffix = "_FDZ", csv_path = ID_recode_template, label_suffix = " (rekodiert FDZ)")
```
### Option 2: Recode IDs with application of a template (e.g. created by a previously prepared, different data set).
Here an already existing template was applied.
```{r autoRecode2, eval = FALSE}
template <- read.csv(ID_recode_template)
dat2 <- autoRecode(dat1, var = "ID", suffix = "_FDZ", csv_path = ID_recode_template, template = template,
                   label_suffix = "(rekodiert FDZ)") ## Apply template and overwrite
```

Delete old ID variables if necessary.
```{r removeVars, eval = FALSE}
dat2 <- removeVars(dat2, vars = c("ID"))
```

# -----------------------------------------------------------------------------
## Convert string variables to numeric variables
String variables cause problems in some statistical programs. In addition, it is more difficult to select the answers in the evaluations with string variables than with numerical codes. Therefore, we convert string variables into numeric variables.
To do so, all string variables are identified first.
```{r docall}
all_types <- do.call(rbind, lapply(namesGADS(dat2), function(nam) data.frame(varName = nam, type = class(dat2$dat[[nam]]))))
all_types[all_types$type == "character", ]
```
In this case the variables "ID_name", "info", "subjfav" and "birth" were recognized as string variables. In the next step they can be converted.

### Option 1: convert all string variables automatically (overwrite variables)
```{r allTypes}
charNames <- all_types[all_types$type == "character", "varName"]
for(charName in charNames) {
  dat3 <- multiChar2fac(dat2, vars = charName, var_suffix = "", label_suffix = "")
}
```
### Option 2: Convert string variable individually
Convert to a new variable:
```{r multiChar2fac, eval=FALSE}
dat3 <- multiChar2fac(dat3, vars = c("ID_name", "info", "subjfav", "birth"), var_suffix = "_FDZ", label_suffix = "")
```
Overwrite variable:
```{r multiChar2fac2, eval=FALSE}
dat3 <- multiChar2fac(dat3, vars = c("ID_name", "info", "subjfav", "birth"), var_suffix = "", label_suffix = "")
```

# -----------------------------------------------------------------------------
## Empty variables already in IZA
If variables are of strong data protection concern, they are already emptied directly in the IZA - the data set form, which is provided only via remote computing. This is achieved with the `emptyTheseVariables()` function.
```{r emptyTheseVariables}
extractMeta(dat3, vars = c("info", "ID_name"))
dat3_empty <- c("info",
                "ID_name")
dat4 <- emptyTheseVariables(dat3,
                            vars = dat3_empty,
                            label_suffix = " (Zur Anonymisierung geleert (FDZ))")
extractMeta(dat4, vars = c("info", "ID_name"))
```
`dat4` corresponds to the dataset here, `vars` describes the variables to be emptied and `label_suffix` automatically adds the declaration to the variable label that the data has been emptied for anonymization.

# -----------------------------------------------------------------------------
## Change variable and value labels
Variable and value labels help us with the traceability and comprehensibility of a data set. To change variable or value labels, the functions `ChangeVarLabels()` and `ChangeValLabels()` are helpful. In `ChangeVarLabels()` the variable to be changed is selected under `varName` and with `varLabel` the corresponding label is assigned. `ChangeValLabels()` works the same way, except that the corresponding value is selected, too.
```{r changeVarLabels}
extractMeta(dat4, vars = c("ID_name"))
dat5 <- changeVarLabels(dat4, varName = "ID_name", varLabel = "Vorname")
extractMeta(dat5, vars = c("ID_name", "books"))
dat5 <- changeValLabels(dat5, varName = "books", value = 5, valLabel = "201-500 books")
extractMeta(dat5, vars = c("books"))
```

# -----------------------------------------------------------------------------
## Anonymization: Form grouping variable
For anonymization reasons, we partially form grouping variables for items with a case number <6. To do this, we create a new _FDZ variable by "cloning" the variable we want to group with `cloneVariable()`. For `varName` we enter the original variable name, for `new_varName` we enter the variable name including the appendix "_FDZ". The variable label is automatically adjusted with the option `label_suffix`.
With `recodeGADS()` the old values (`oldValues`) are replaced by new ones (`newValues`). With the help of `changeValLabels()` the value labels of the new groupings are changed.
```{r recodeGADS}
extractMeta(dat5, vars = c("age"))
dat5 <- cloneVariable(dat5, varName = "age", new_varName = "age_FDZ", label_suffix = " (Zur Anonymisierung aggregiert (FDZ))")

dat5 <- recodeGADS(dat5, varName = "age_FDZ", oldValues = c(13, 14, 15, 17),
                  newValues = c(13, 13, 15, 15))
dat5 <- changeValLabels(dat5, varName = "age_FDZ", value = c(13, 15), valLabel = c("13-14", "15-17"))
extractMeta(dat5, vars = c("age_FDZ"))
```
You can also perform grouping for multiple variables using a loop. For this we give the variables a temporary name consisting of the variable name and the suffix "_FDZ". `varname` stands here for each individual variable, which was summarized before in `gr_var`. The individual steps (`cloneVariable()`, `recodeGADS()`,`changeValLabels()`) are therefore performed for each of the variables in turn.
```{r recodeGADS_loop}
extractMeta(dat5, vars = c("grade_math"))
dat6 <- dat5
gr_var <- c("grade_math", "grade_germ", "grade_eng")
for (varname in gr_var) {
  tempnewname <- paste0(varname, "_FDZ")
  dat6 <- cloneVariable(dat6, varName = varname,
                        new_varName = tempnewname, label_suffix = " (Zur Anonymisierung aggregiert (FDZ))")
  dat6 <- recodeGADS(dat6, varName = tempnewname,
                      oldValues = c(1:6),
                      newValues = c(rep(1,4),rep(2,2)))
  dat6 <- changeValLabels(dat6, varName = tempnewname, value = c(1, 2),
                           valLabel = c("passed", "not passed"))
}
extractMeta(dat6, vars = c("grade_math_FDZ"))
```

# -----------------------------------------------------------------------------
## Define missing values
Using `changeMissings()`, missing values can be tagged as missings by specifying them under `value` and marking them as `miss` under `missings.`
```{r changeMissings}
extractMeta(dat6, vars = c("school"))
dat7 <- changeMissings(dat6, varName = "school", value = c(-97, -98, -99), missings = c("miss", "miss", "miss"))
extractMeta(dat7, vars = c("school"))
```

# -----------------------------------------------------------------------------
## Creating the version variable
To indicate the state of the dataset, each dataset is provided with a version variable. This is created using `createVariable()` and placed at the beginning of the record by `relovateVariable()` so that it has a consistent, visible place.
```{r VersionsVar}
version_name <- "Version_v1_2023_07"
dat8 <- createVariable(dat7, varName = version_name)
dat8 <- relocateVariable(dat8, var = version_name, after = NULL)
```

# -----------------------------------------------------------------------------
## Change variable order
To rearrange the variables of a data set, the function `orderLike()` helps, in which the variables are listed in their new order.
```{r orderLike}
dat9 <- orderLike(dat8, newOrder = c("Version_v1_2023_07", "ID", "ID_name", "info", "home", "birth", "age", "age_FDZ", "sex", "siblings", "books", "school", "subjfav", "grade_math", "grade_math_FDZ", "grade_germ", "grade_germ_FDZ", "grade_eng", "grade_eng_FDZ"))
```
To sort in individual variables, such as newly created grouping variables behind their emptied original variable, `relocateVariable()` can be used.
```{r relocateVariable}
dat9 <- relocateVariable(dat9, var = "age_FDZ", after = "age")
```
